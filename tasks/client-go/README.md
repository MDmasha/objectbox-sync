# Example: Tasks
This example shows how to use the ObjectBox's GO API to create a simple console-base task-list application.

To start the program just build & run the main.go, which launches an interactive console application

```
Welcome to the ObjectBox tasks-list app example
Available commands are: 
    ls [-a]        list tasks - unfinished or all (-a flag)
    new Task text  create a new task with the text 'Task text'
    done ID        mark task with the given ID as done
    exit           close the program
    help           display this help
$ 
```

To create a new task, you can just type `new Buy milk` and hit enter. 

Now you can display the list of open tasks by running `ls`
```bash
 ID  Created                        Finished                       Text
  1  2018-11-14 14:36:57 +0100 CET                                 Buy milk
```

To complete a task, you would execute command `done 1` (1 is the ID of the task as shown above).
And to show all tasks, including the finished ones, you can run `ls -a`.

### Code overview
Files:

* [main.go](main.go): actual example code
* [internal/model/task.go](internal/model/task.go): Task struct declaration
* Other files in the [internal/model directory](internal/model) are generated by objectbox-gogen bindings generator utility.

#### Code organization

1. The `main()` sets up ObjectBox store and auto-generated `TasksBox` which simplifies working with Tasks inside ObjectBox  
1. `initObjectBox()` is the method that actually does ObjectBox setup based on the model. Note the unique IDs for the lastEntity 
and the call to `RegisterBinding` - they make sure the database schema is up-to-date with the code. 
1. The `runInteractiveShell()` is just a command executor and doesn't contain any ObjectBox related code. 
It displays the shell and blocks until an `exit` command is entered.
1. After the exit command, execution of the program is back in the `main()` and objectbox is closed properly.
Note that the `box` is closed before `ob` (ObjectBox) by the design of GO defer statement (last-in-first-out).

The following methods demonstrate some of the API capabilities: 

* `printList()` - iterates over the whole dataset (calls `box.GetAll()`) and displays tasks in a table
* `createTask()` - insert (calls `box.Put()`) 
* `setDone()` - select `box.Get()` & update `box.Put()`
 
### Changing the data model
When the model is changed, you need to run `go generate` inside the model folder so that the generated bindings are updated.
For convenience, the auto-generated files `task.obx.go` and `objectbox-model.json` are already generated for this example.

You may want to change the data model to expend the example or to start your own data model for a new app.
Here's what you have to do:

1. Edit `task.go` 
2. Regenerate bindings and update model-info using [go generate](https://blog.golang.org/generate). 
For the `go generate` command to work, you need to have objectbox-gogen, a command line utility we have built for this purpose, installed and recognized in `$PATH`.
3. Once the bindings are changed, you might need to adjust your `initObjectBox()` if you have added an entity - register bindings for completely new entities and update ID/UID

Some quick notes on IDs and UIDs in the ObjectBox model:

* Entity IDs need to be unique among themselves
* Property IDs need to be unique inside their Entity
* All UIDs need to be unique application-wide
* See [Meta Model, IDs, and UIDs](https://docs.objectbox.io/advanced/meta-model-ids-and-uids) docs for more details.

### License
    Copyright 2018-2021 ObjectBox Ltd. All rights reserved.
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
